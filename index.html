<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>THREE.js EAC test</title>
    <style>
        body {
            background-color: #ccc;
            color: #000;
        }

        a {
            color: #f00;
        }
    </style>
</head>
<body>


<script type="module">

  import * as THREE from './three.module.js';
  import { VertexFaceNumbersHelper } from './vertexFaceNumberHelper.js';

  import { OrbitControls } from './OrbitControls.js';

  let camera, controls, scene, renderer;
  const SEGMENTS = 5;
  let vertexFaceNumbersHelper2;

  init();
  //render(); // remove when using next line for animation loop (requestAnimationFrame)
  animate();

  function init() {

    scene = new THREE.Scene();
    scene.background = new THREE.Color( 0xcccccc );
    scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );

    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
    // camera.position.set(20, 20, 20);

    // controls
    const controls = new OrbitControls( camera, renderer.domElement );
    controls.target.x = 0.01;
    camera.lookAt(0.01, 0, 0);

    var material = new THREE.MeshBasicMaterial( { color: 0x0000ff, wireframe: true } );

    var geometry1 = new THREE.BoxGeometry( 100, 100, 100, SEGMENTS, SEGMENTS, SEGMENTS );
    var mesh1 = new THREE.Mesh( geometry1, material );
    scene.add( mesh1 );
    vertexFaceNumbersHelper2 = new VertexFaceNumbersHelper( mesh1, 1, 2, camera );
    vertexFaceNumbersHelper2.update( 1 );

    // lights

    const dirLight1 = new THREE.DirectionalLight( 0xffffff );
    dirLight1.position.set( 1, 1, 1 );
    scene.add( dirLight1 );

    const dirLight2 = new THREE.DirectionalLight( 0x002288 );
    dirLight2.position.set( - 1, - 1, - 1 );
    scene.add( dirLight2 );

    const ambientLight = new THREE.AmbientLight( 0x222222 );
    scene.add( ambientLight );

    //

    window.addEventListener( 'resize', onWindowResize );

  }

  function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

  }

  function animate() {

    requestAnimationFrame( animate );
    if(vertexFaceNumbersHelper2) {
      vertexFaceNumbersHelper2.update(1);
    }

    // controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true

    render();

  }

  function render() {

    renderer.render( scene, camera );

  }



  const segments = 5;


  // for(let k = 0; k < (segments + 1); k ++) {
  //
  // }



  const offset = (segments + 1) ^ 2; // = 36;


  const uvs = [];


  for(let k = 0; k < segments + 1; k++) {
    for(let i = 0; i < segments + 1; i ++) {
      const index = offset + k * (segments + 1) + i;
      const [x, y] = [1/2 - i/(segments), 1/2 - k/(segments)];
      const [u, v] = [
        1/2 + (2/Math.PI) * Math.atan(2*x),
        1/2 + (2/Math.PI) * Math.atan(2*y)
      ];

      const [imagex, imagey] = [
        1/3 + (v/3),
        1/2 - u* 0.5,
      ]
      uvs[index*2] = imagex;
      uvs[index * 2 + 1] = imagey;
    }

    // 65;




  }





</script>


</body>
</html>
